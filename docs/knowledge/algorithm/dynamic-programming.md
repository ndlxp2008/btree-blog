# 动态规划

动态规划(Dynamic Programming, DP)是一种通过将复杂问题分解成更简单的子问题来解决问题的算法设计范式。它将子问题的解存储起来，避免重复计算，从而显著提高算法效率。本文档介绍动态规划的基本概念、设计步骤以及常见应用场景。

## 1. 基本概念

### 1.1 定义

动态规划是解决具有重叠子问题和最优子结构特性的问题的算法技术。

### 1.2 重叠子问题

当问题的递归算法反复求解相同的子问题时，我们称该问题具有重叠子问题特性。动态规划通过存储已解决子问题的结果来避免重复计算。

### 1.3 最优子结构

如果问题的最优解包含其子问题的最优解，则该问题具有最优子结构特性。这使得我们可以通过组合子问题的最优解来构建原问题的最优解。

### 1.4 与分治法的比较

- **分治法**: 将问题分解为互不相交的子问题，独立解决后合并结果
- **动态规划**: 适用于子问题重叠的情况，保存子问题的解以避免重复计算

## 2. 动态规划的设计步骤

### 2.1 定义状态

明确定义子问题，并选择合适的状态表示。状态通常是问题规模较小的变种。

### 2.2 建立状态转移方程

找出状态之间的关系，即如何从已解决的子问题推导出当前问题的解。

### 2.3 确定边界条件

确定最小规模子问题的解，作为递推的起点。

### 2.4 确定计算顺序

根据状态转移方程的依赖关系，确定子问题的计算顺序。

### 2.5 实现方案

根据以上分析实现具体的算法，可选择自顶向下（记忆化搜索）或自底向上（迭代）的方式。

## 3. 实现方法

### 3.1 自顶向下（记忆化搜索）

使用递归结合备忘录来避免重复计算。

```java
// 斐波那契数列的记忆化搜索实现
public int fibonacci(int n, int[] memo) {
    if (n <= 1) {
        return n;
    }

    if (memo[n] != 0) {
        return memo[n];  // 使用已经计算过的结果
    }

    memo[n] = fibonacci(n-1, memo) + fibonacci(n-2, memo);
    return memo[n];
}

// 调用方式
// int[] memo = new int[n+1];
// int result = fibonacci(n, memo);
```

### 3.2 自底向上（迭代）

从最小子问题开始，逐步构建更大规模问题的解。

```java
// 斐波那契数列的迭代实现
public int fibonacci(int n) {
    if (n <= 1) {
        return n;
    }

    int[] dp = new int[n+1];
    dp[0] = 0;
    dp[1] = 1;

    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i-1] + dp[i-2];
    }

    return dp[n];
}
```

### 3.3 空间优化

很多动态规划问题可以通过只保留必要的状态来优化空间复杂度。

```java
// 斐波那契数列的空间优化实现
public int fibonacci(int n) {
    if (n <= 1) {
        return n;
    }

    int prev = 0;
    int curr = 1;

    for (int i = 2; i <= n; i++) {
        int next = prev + curr;
        prev = curr;
        curr = next;
    }

    return curr;
}
```

## 4. 经典动态规划问题

### 4.1 斐波那契数列

**问题**: 计算斐波那契数列的第n个数。

**状态定义**: `dp[i]` 表示第i个斐波那契数。

**状态转移方程**: `dp[i] = dp[i-1] + dp[i-2]`

**边界条件**: `dp[0] = 0, dp[1] = 1`

```java
// 代码实现
public int fib(int n) {
    if (n <= 1) return n;

    int[] dp = new int[n+1];
    dp[0] = 0;
    dp[1] = 1;

    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i-1] + dp[i-2];
    }

    return dp[n];
}
```

### 4.2 爬楼梯问题

**问题**: 假设你正在爬楼梯，需要n步才能到达楼顶。每次你可以爬1或2个台阶，求有多少种不同的方法可以爬到楼顶？

**状态定义**: `dp[i]` 表示爬到第i个台阶的方法数。

**状态转移方程**: `dp[i] = dp[i-1] + dp[i-2]`（可以从i-1跨1步或从i-2跨2步到达i）

**边界条件**: `dp[1] = 1, dp[2] = 2`

```java
public int climbStairs(int n) {
    if (n <= 2) return n;

    int[] dp = new int[n+1];
    dp[1] = 1;
    dp[2] = 2;

    for (int i = 3; i <= n; i++) {
        dp[i] = dp[i-1] + dp[i-2];
    }

    return dp[n];
}
```

### 4.3 最长递增子序列 (LIS)

**问题**: 给定一个无序的整数数组，找到其中最长上升子序列的长度。

**状态定义**: `dp[i]` 表示以第i个元素结尾的最长递增子序列的长度。

**状态转移方程**: `dp[i] = max(dp[j] + 1)` 其中 `0 ≤ j < i` 且 `nums[j] < nums[i]`

**边界条件**: 所有`dp[i]`初始化为1（单个元素可以形成长度为1的子序列）

```java
public int lengthOfLIS(int[] nums) {
    if (nums == null || nums.length == 0) {
        return 0;
    }

    int n = nums.length;
    int[] dp = new int[n];
    Arrays.fill(dp, 1);  // 初始化

    int maxLength = 1;

    for (int i = 1; i < n; i++) {
        for (int j = 0; j < i; j++) {
            if (nums[i] > nums[j]) {
                dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }
        maxLength = Math.max(maxLength, dp[i]);
    }

    return maxLength;
}
```

### 4.4 背包问题

#### 4.4.1 0-1背包问题

**问题**: 给定n个物品，每个物品有重量w和价值v。现在有一个容量为W的背包，问如何选择物品放入背包，使得背包内物品的总价值最大？

**状态定义**: `dp[i][j]` 表示考虑前i个物品，背包容量为j时能获得的最大价值。

**状态转移方程**:
- 不选第i个物品：`dp[i][j] = dp[i-1][j]`
- 选择第i个物品：`dp[i][j] = dp[i-1][j-w[i]] + v[i]`（前提是`j ≥ w[i]`）
- 取两者最大值

**边界条件**: `dp[0][j] = 0, dp[i][0] = 0`

```java
public int knapsack01(int[] weights, int[] values, int capacity) {
    int n = weights.length;
    int[][] dp = new int[n+1][capacity+1];

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= capacity; j++) {
            if (weights[i-1] > j) {
                // 当前物品太重，无法放入
                dp[i][j] = dp[i-1][j];
            } else {
                // 选择不放或放入当前物品中价值较大的选项
                dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-weights[i-1]] + values[i-1]);
            }
        }
    }

    return dp[n][capacity];
}
```

#### 4.4.2 完全背包问题

**问题**: 与0-1背包类似，但每种物品有无限数量可用。

**状态转移方程**:
`dp[i][j] = max(dp[i-1][j], dp[i][j-w[i]] + v[i])`

注意这里是`dp[i][j-w[i]]`而不是`dp[i-1][j-w[i]]`，因为第i种物品可以重复使用。

```java
public int unboundedKnapsack(int[] weights, int[] values, int capacity) {
    int n = weights.length;
    int[][] dp = new int[n+1][capacity+1];

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= capacity; j++) {
            if (weights[i-1] > j) {
                dp[i][j] = dp[i-1][j];
            } else {
                dp[i][j] = Math.max(dp[i-1][j], dp[i][j-weights[i-1]] + values[i-1]);
            }
        }
    }

    return dp[n][capacity];
}
```

### 4.5 最长公共子序列 (LCS)

**问题**: 给定两个字符串，找出它们的最长公共子序列的长度。

**状态定义**: `dp[i][j]` 表示字符串1的前i个字符与字符串2的前j个字符的最长公共子序列长度。

**状态转移方程**:
- 如果`s1[i-1] == s2[j-1]`，则`dp[i][j] = dp[i-1][j-1] + 1`
- 否则，`dp[i][j] = max(dp[i-1][j], dp[i][j-1])`

**边界条件**: `dp[0][j] = 0, dp[i][0] = 0`

```java
public int longestCommonSubsequence(String text1, String text2) {
    int m = text1.length();
    int n = text2.length();
    int[][] dp = new int[m+1][n+1];

    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (text1.charAt(i-1) == text2.charAt(j-1)) {
                dp[i][j] = dp[i-1][j-1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);
            }
        }
    }

    return dp[m][n];
}
```

### 4.6 编辑距离

**问题**: 给定两个单词word1和word2，计算将word1转换成word2所需的最少操作数（插入、删除或替换一个字符）。

- 状态定义为一维数组
- 每个状态只依赖于前面的有限个状态
- 例如：最长递增子序列、最大子数组和

### 2. 区间动态规划

- 状态定义与区间相关
- 通常由小区间向大区间推进
- 例如：矩阵链乘法、石子合并问题

### 3. 背包类动态规划

- 状态与容量相关
- 包括0-1背包、完全背包、多重背包等
- 例如：分割等和子集、零钱兑换

### 4. 树形动态规划

- 在树结构上进行动态规划
- 通常结合DFS实现
- 例如：树的直径、树的独立集

### 5. 状态压缩动态规划

- 使用二进制表示状态
- 通常用于处理指数级状态空间
- 例如：旅行商问题、集合操作问题

### 6. 数位动态规划

- 按照数字的位进行处理
- 通常用于计数类问题
- 例如：不包含特定数字的整数个数

## 动态规划优化技巧

### 1. 状态压缩

使用位运算表示状态，减少状态数量和存储空间。

### 2. 空间优化

利用滚动数组或只保留必要的状态，将空间复杂度从 O(n²) 降至 O(n) 或 O(1)。

### 3. 预处理

提前计算和存储一些值，减少重复计算。

### 4. 记忆化搜索

结合递归和记忆化，有时比纯自底向上实现更简洁。

## 如何识别动态规划问题

1. **问题询问最优解**：最大值、最小值、最长、最短等
2. **可以分解为子问题**：问题的解可以由子问题的解构建
3. **存在重叠子问题**：相同的子问题被多次求解
4. **是否需要做决策**：每一步需要在多个选择中选最优

## 动态规划的局限性

1. **状态难以定义**：有些问题难以找到合适的状态表示
2. **状态空间过大**：有些问题的状态数量呈指数级增长
3. **状态转移复杂**：有些问题的状态转移方程难以确定
4. **贪心更高效**：有些问题使用贪心算法更简单高效

## 实际应用中的动态规划

1. **计算机图形学**：图像分割、曲线拟合
2. **自然语言处理**：语音识别、文本分类
3. **生物信息学**：序列比对、RNA结构预测
4. **控制理论**：最优控制策略
5. **运筹学**：资源调度、生产规划

## 总结

动态规划是解决优化问题的强大工具，通过将复杂问题分解为子问题并存储子问题解来避免重复计算。掌握动态规划需要：

1. 理解问题的最优子结构特性
2. 准确定义状态和状态转移方程
3. 确定合适的求解顺序
4. 根据问题特点选择适当的实现方法和优化技巧

通过系统练习，动态规划思想可以成为解决复杂优化问题的有力武器。