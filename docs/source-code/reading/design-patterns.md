# 通用设计模式

## 1. 引言

### 1.1 什么是设计模式？
设计模式（Design Pattern）是在软件开发过程中，针对特定问题、经过反复实践、总结出的优雅且可复用的解决方案。它们不是具体的代码，而是一种思想和模式，描述了类和对象之间如何交互以解决常见的设计问题。

### 1.2 设计模式的重要性
- **提高代码复用性**：模式提供了经过验证的解决方案，避免重复造轮子。
- **提高代码可读性**：使用标准模式使得其他开发者更容易理解代码意图。
- **提高代码可维护性**：遵循模式的代码结构更清晰，易于修改和扩展。
- **促进团队沟通**：模式提供了通用的设计词汇，方便团队成员交流。

### 1.3 GoF设计模式分类
经典的《设计模式：可复用面向对象软件的基础》（GoF）一书将23种设计模式分为三类：
- **创建型模式 (Creational Patterns)**：关注对象的创建过程，将创建过程与使用过程解耦。
- **结构型模式 (Structural Patterns)**：关注类和对象的组合，形成更大的结构。
- **行为型模式 (Behavioral Patterns)**：关注类和对象之间的职责分配和协作。

---

## 2. 创建型模式

处理对象创建机制，试图以适合情况的方式创建对象。

- **单例模式 (Singleton)**：确保一个类只有一个实例，并提供一个全局访问点。
    *   *应用场景*：日志记录器、配置管理器、线程池等。
    *   *源码示例*：Spring框架中的Bean默认是单例的。
- **工厂方法模式 (Factory Method)**：定义一个用于创建对象的接口，让子类决定实例化哪一个类。
    *   *应用场景*：需要根据不同条件创建不同类型对象，但具体类型由子类决定。
    *   *源码示例*：Java `Calendar.getInstance()`、`Collection`接口的`iterator()`方法。
- **抽象工厂模式 (Abstract Factory)**：提供一个接口，用于创建一系列相关或依赖的对象，而无需指定它们的具体类。
    *   *应用场景*：需要创建一组相关的对象（产品族），如不同操作系统的UI组件。
    *   *源码示例*：Java `javax.xml.parsers`包用于创建不同XML解析器。
- **建造者模式 (Builder)**：将一个复杂对象的构建与其表示分离，使得同样的构建过程可以创建不同的表示。
    *   *应用场景*：对象有多个组成部分，且构建过程复杂或需要按步骤进行。
    *   *源码示例*：`StringBuilder`、MyBatis `SqlSessionFactoryBuilder`。
- **原型模式 (Prototype)**：用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。
    *   *应用场景*：创建新对象成本较高（如初始化复杂或需要DB/IO操作），或需要创建大量相似对象。
    *   *源码示例*：Java `Object.clone()`。

---

## 3. 结构型模式

关注如何将类或对象组合成更大的结构，同时保持结构的灵活性和效率。

- **适配器模式 (Adapter)**：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
    *   *应用场景*：需要复用现有类，但其接口与需求不符；需要统一多个类的接口。
    *   *源码示例*：Java `Arrays.asList()`、各种JDBC驱动。
- **桥接模式 (Bridge)**：将抽象部分与它的实现部分分离，使它们都可以独立地变化。
    *   *应用场景*：一个类存在两个或多个独立变化的维度，且希望避免维度组合带来的类爆炸。
    *   *源码示例*：JDBC驱动管理器(`DriverManager`)与具体驱动的关系。
- **组合模式 (Composite)**：将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。
    *   *应用场景*：需要表示对象的树形结构，并希望统一处理叶子节点和容器节点。
    *   *源码示例*：UI组件（如Swing/AWT的容器和控件）、文件系统目录结构。
- **装饰器模式 (Decorator)**：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。
    *   *应用场景*：需要在不修改原有对象代码的情况下，为其动态添加功能或行为。
    *   *源码示例*：Java IO类（如`BufferedReader`包装`Reader`）、Servlet API的`HttpServletRequestWrapper`。
- **外观模式 (Facade)**：为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
    *   *应用场景*：为一个复杂的子系统提供简单的接口；降低客户端与子系统之间的耦合。
    *   *源码示例*：SLF4J日志门面、MyBatis `SqlSession`。
- **享元模式 (Flyweight)**：运用共享技术有效地支持大量细粒度的对象。
    *   *应用场景*：系统中存在大量相似对象，且这些对象的内部状态可以共享。
    *   *源码示例*：Java `Integer.valueOf()`（缓存-128到127的Integer对象）、数据库连接池。
- **代理模式 (Proxy)**：为其他对象提供一种代理以控制对这个对象的访问。
    *   *应用场景*：延迟加载（虚拟代理）、访问控制（保护代理）、远程访问（远程代理）、日志/事务（动态代理）。
    *   *源码示例*：Spring AOP（动态代理）、RPC框架（远程代理）。

---

## 4. 行为型模式

涉及算法和对象间职责的分配。它们描述了对象和类的交互方式以及职责划分。

- **责任链模式 (Chain of Responsibility)**：为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。
    *   *应用场景*：多个对象可以处理同一个请求，但具体哪个对象处理由运行时决定；需要动态指定处理者链。
    *   *源码示例*：Servlet Filter链、Netty `ChannelPipeline`。
- **命令模式 (Command)**：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。
    *   *应用场景*：需要将请求发送者与接收者解耦；需要支持请求排队、日志记录、撤销/重做。
    *   *源码示例*：`Runnable`接口、线程池的任务提交。
- **解释器模式 (Interpreter)**：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。
    *   *应用场景*：需要定义一种简单的语言并解析执行其语句，如正则表达式解析、SQL解析。
    *   *源码示例*：`java.util.regex.Pattern`、Spring Expression Language (SpEL)。
- **迭代器模式 (Iterator)**：提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。
    *   *应用场景*：需要遍历聚合对象，且希望隐藏其内部结构。
    *   *源码示例*：Java `Iterator`接口及其实现类。
- **中介者模式 (Mediator)**：用一个中介对象来封装一系列的对象交互。中介者使各个对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
    *   *应用场景*：对象之间存在复杂的网状交互关系，希望通过一个中心点来协调。
    *   *源码示例*：GUI框架中的事件分发（如`java.awt.event.EventQueue`）、`Timer`调度任务。
- **备忘录模式 (Memento)**：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。
    *   *应用场景*：需要保存和恢复对象状态，如撤销/重做功能、事务回滚。
    *   *源码示例*：Java `Serializable`接口（某种程度）、状态机快照。
- **观察者模式 (Observer)**：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
    *   *应用场景*：一个对象状态的改变需要通知其他多个对象；发布/订阅模型。
    *   *源码示例*：`java.util.Observer`/`Observable`（已废弃）、`java.util.EventListener`、Spring事件监听机制、消息队列。
- **状态模式 (State)**：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。
    *   *应用场景*：对象的行为依赖于其状态，且状态之间可以相互转换。
    *   *源码示例*：TCP连接状态、工作流引擎。
- **策略模式 (Strategy)**：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。
    *   *应用场景*：有多种算法或行为可供选择，并希望在运行时动态切换。
    *   *源码示例*：`Comparator`接口、`ThreadPoolExecutor`的拒绝策略。
- **模板方法模式 (Template Method)**：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
    *   *应用场景*：固定算法流程，但某些步骤的具体实现可能不同。
    *   *源码示例*：`HttpServlet`的`doGet`/`doPost`方法、`AbstractList`。
- **访问者模式 (Visitor)**：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。
    *   *应用场景*：对象结构相对稳定，但需要对结构中的元素执行多种不同的操作。
    *   *源码示例*：编译器（语法树遍历）、XML文档处理。

---

## 5. 设计模式在源码中的应用

### 5.1 如何识别设计模式
- **看类名/接口名**：有时命名会直接体现模式（如 `xxxFactory`, `xxxBuilder`, `xxxAdapter`, `xxxDecorator`, `xxxProxy`, `xxxObserver`, `xxxStrategy`, `xxxTemplate`）。
- **看类/对象关系**：分析类图、继承关系、依赖关系。例如，单例模式只有一个实例；工厂模式有创建产品的接口和实现；装饰器模式有共同的父类或接口，并持有被装饰对象的引用；策略模式有策略接口和多个实现类。
- **看方法签名和实现**：模板方法有`final`的骨架方法和`abstract`的步骤方法；迭代器模式有`hasNext()`和`next()`。
- **理解代码意图**：思考代码要解决什么问题。是为了创建对象？组合对象？还是协调对象行为？

### 5.2 常见框架中的设计模式示例
- **Spring框架**：
    - **工厂模式/抽象工厂模式**：`BeanFactory`, `ApplicationContext`用于创建和管理Bean。
    - **单例模式**：默认Bean作用域。
    - **代理模式**：AOP（面向切面编程）广泛使用动态代理。
    - **模板方法模式**：`JdbcTemplate`, `RestTemplate`等 `xxxTemplate` 类。
    - **观察者模式**：Spring事件监听机制 (`ApplicationEvent`, `ApplicationListener`)。
    - **策略模式**：`Resource`接口的不同实现（`UrlResource`, `ClassPathResource`）。
- **Netty框架**：
    - **工厂方法模式**：`ChannelFactory`。
    - **责任链模式**：`ChannelPipeline`和`ChannelHandler`。
    - **装饰器模式**：可以通过`ChannelPipeline`动态添加或移除`ChannelHandler`来增强功能。
    - **观察者模式**：`ChannelFuture`的监听器。
- **MyBatis框架**：
    - **工厂模式**：`SqlSessionFactory`。
    - **建造者模式**：`SqlSessionFactoryBuilder`。
    - **代理模式**：Mapper接口的动态代理实现。
    - **模板方法模式**：`BaseExecutor`定义了执行SQL的基本流程。

---

## 6. 总结

设计模式是前人智慧的结晶，是提升软件设计质量的重要工具。理解和掌握常见的设计模式，并在阅读源码和实际开发中识别和应用它们，能够帮助我们编写出更灵活、可维护、可复用的高质量代码。但也要避免过度设计，应根据实际场景恰当选用模式。

---
