# Redis 持久化源码分析

## 1. 引言

Redis 提供了两种主要的持久化机制，用于在服务器重启时恢复数据：
- **RDB (Redis Database Backup)**：在指定的时间间隔内生成数据集的时间点快照（Snapshot）。
- **AOF (Append Only File)**：记录服务器接收到的所有写操作命令，并在服务器启动时重新执行这些命令来恢复数据。

了解这两种持久化机制的源码实现对于理解 Redis 的数据安全、性能以及故障恢复能力至关重要。

---

## 2. RDB 持久化

### 2.1 RDB 触发方式
RDB 持久化可以通过以下方式触发：
- **`SAVE` 命令**：阻塞 Redis 服务器进程，直到 RDB 文件创建完毕。在生产环境中很少直接使用。
- **`BGSAVE` 命令**：服务器 fork 一个子进程，由子进程负责创建 RDB 文件，父进程继续处理客户端请求。这是常用的方式。
- **配置文件自动触发**：`redis.conf` 中配置 `save <seconds> <changes>` 规则，当在指定秒数内发生指定次数的修改时，自动触发 `BGSAVE`。
- **`SHUTDOWN` 命令**：在关闭服务器前执行 `SAVE`。
- **主从复制**：从节点请求全量同步时，主节点会执行 `BGSAVE` 生成 RDB 文件发送给从节点。

### 2.2 RDB 文件创建流程 (`BGSAVE`)
1.  **主进程检查**：主进程检查当前是否有正在进行的 `BGSAVE` 或 AOF 重写，如果有则直接返回。
2.  **`fork()` 子进程**：主进程调用 `fork()` 创建子进程 (`rdb.c/rdbSaveBackground`)。
    -   `fork()` 期间主进程阻塞。
    -   `fork()` 利用写时复制（Copy-On-Write, COW）机制，子进程可以共享父进程的内存数据。
3.  **子进程执行 RDB 保存**：
    -   子进程调用 `rdb.c/rdbSave` 函数开始生成 RDB 文件。
    -   它会创建一个临时文件，然后将数据库快照写入该临时文件。
    -   遍历所有数据库，将键值对按照特定格式（类型、过期时间、Key、Value）序列化写入文件。这个过程不涉及网络 IO，主要是 CPU 和磁盘 IO 操作。
    -   使用压缩算法（如 LZF）可以减小 RDB 文件大小，但会消耗更多 CPU。
4.  **临时文件替换**：子进程成功生成 RDB 文件后，使用原子性的 `rename` 操作将临时文件替换掉旧的 RDB 文件 (`dump.rdb`)。
5.  **子进程退出通知**：子进程向父进程发送信号，告知 RDB 创建完成。
6.  **主进程更新状态**：父进程收到子进程完成信号后，更新相关状态（如 `dirty` 计数器、最后保存时间等）。

### 2.3 RDB 文件结构
RDB 文件是一个经过压缩的二进制文件，其大致结构如下：
- `REDIS` 魔数 (5字节)
- RDB 版本号 (4字节)
- 辅助字段 (Key-Value形式，如 redis-ver, redis-bits, ctime, used-mem)
- `SELECTDB` 操作码 + 数据库号码
- `RESIZEDB` 操作码 + 哈希表大小 + 过期哈希表大小
- 键值对数据：
    - `EXPIRETIME_MS` (可选) + 毫秒时间戳
    - 类型编码 (1字节，如 `REDIS_RDB_TYPE_STRING`)
    - Key (带长度前缀的字符串)
    - Value (根据类型不同，编码方式不同)
- `EOF` 结束符 (1字节)
- CRC64 校验和 (8字节)

### 2.4 RDB 加载
Redis 服务器启动时，如果开启了 RDB 持久化且 `dump.rdb` 文件存在，服务器会调用 `rdb.c/rdbLoad` 函数加载 RDB 文件恢复数据。
- 加载过程是阻塞的，服务器无法处理客户端请求。
- 读取文件内容，根据 RDB 文件格式反序列化出键值对，并添加到内存数据库中。

### 2.5 RDB 优缺点
- **优点**：
    - 文件紧凑，适合备份和灾难恢复。
    - 加载速度通常比 AOF 快。
    - 对性能影响相对较小（`BGSAVE` 使用子进程）。
- **缺点**：
    - 数据丢失风险较高，最后一次 RDB 生成后到服务器宕机之间的数据会丢失。
    - `fork()` 可能导致服务短暂暂停，尤其在内存较大时。

---

## 3. AOF 持久化

### 3.1 AOF 开启与配置
在 `redis.conf` 中设置 `appendonly yes` 来开启 AOF。

### 3.2 AOF 写入流程
1.  **命令追加 (`feedAppendOnlyFile`)**：服务器执行完一个写命令后，会将该命令以 Redis 协议格式追加到 AOF 缓冲区 (`server.aof_buf`)。
2.  **缓冲区同步 (`flushAppendOnlyFile`)**：根据 `appendfsync` 配置策略，将 AOF 缓冲区的内容写入（`write`）并同步（`fsync`）到 AOF 文件（`appendonly.aof`）的末尾。
    -   **`always`**: 每个写命令都立即同步，最安全但最慢。
    -   **`everysec`** (默认): 每秒同步一次，性能和安全的折中。由后台线程（`bio.c` 中的 BIO_AOF_FSYNC 类型任务）执行 `fsync`。
    -   **`no`**: 由操作系统决定何时同步，最快但最不安全。

### 3.3 AOF 文件格式
AOF 文件是纯文本文件，存储的是 Redis 命令的协议格式。例如：
```
*3
$3
SET
$3
key
$5
value
```

### 3.4 AOF 加载
服务器启动时，如果开启了 AOF，会优先加载 AOF 文件（而非 RDB）来恢复数据 (`aof.c/loadAppendOnlyFile`)。
- 创建一个伪客户端（fake client）。
- 逐条读取 AOF 文件中的命令。
- 使用伪客户端执行这些命令，重建数据库状态。

### 3.5 AOF 重写 (Rewrite)
由于 AOF 文件会不断增大，Redis 提供了 AOF 重写机制来压缩 AOF 文件大小。
- **触发方式**：
    - `BGREWRITEAOF` 命令。
    - 配置文件自动触发 (`auto-aof-rewrite-percentage`, `auto-aof-rewrite-min-size`)。
- **流程 (`rewriteAppendOnlyFileBackground`)**：
    1.  **主进程检查**：检查是否有正在进行的 `BGSAVE` 或 AOF 重写。
    2.  **`fork()` 子进程**：主进程 `fork()` 创建子进程。
    3.  **子进程执行重写**：
        -   子进程遍历当前内存数据库，将每个键值对转换成一条或多条设置命令（例如集合会转换成多条 `SADD`）。
        -   将这些命令写入一个新的临时 AOF 文件。这个过程不读取旧 AOF 文件，只依赖当前内存数据。
    4.  **处理增量写入（AOF 重写缓冲区）**：在子进程重写期间，父进程收到的写命令会同时写入：
        -   旧的 AOF 缓冲区（`server.aof_buf`）照常写入旧 AOF 文件。
        -   **AOF 重写缓冲区**（`server.aof_rewrite_buf_blocks`）。
    5.  **合并增量**：子进程完成内存快照的写入后，父进程会将 AOF 重写缓冲区中的内容追加到子进程创建的临时 AOF 文件末尾。
    6.  **原子替换**：使用 `rename` 将新的临时 AOF 文件替换旧的 AOF 文件。
    7.  **主进程切换**：主进程后续的写命令将写入新的 AOF 文件。

### 3.6 AOF 优缺点
- **优点**：
    - 数据丢失风险低（取决于 `appendfsync` 策略）。
    - 文件内容可读，易于理解和修复。
- **缺点**：
    - 文件体积通常比 RDB 大。
    - 加载速度通常比 RDB 慢。
    - `fsync` 操作可能影响性能（尤其是 `always` 策略）。

---

## 4. RDB 与 AOF 混合持久化 (Redis 4.0+)

为了结合 RDB 和 AOF 的优点，Redis 4.0 引入了混合持久化。
- **开启**：设置 `aof-use-rdb-preamble yes`。
- **工作方式**：在 AOF 重写时，子进程不再是生成一系列命令，而是将内存快照以 RDB 格式写入新 AOF 文件的开头，然后将 AOF 重写缓冲区中的增量命令以 AOF 格式追加在 RDB 内容之后。
- **文件结构**：`[RDB Preamble][AOF Commands]`
- **加载**：服务器加载时，先识别并加载 RDB 部分，然后再加载 AOF 部分。
- **优点**：兼顾了 RDB 加载速度快和 AOF 数据丢失风险低的特点。

---

## 5. 关键源码文件

- `rdb.c`: RDB 文件的保存和加载逻辑。
- `aof.c`: AOF 文件的写入、加载、重写逻辑。
- `redis.c`: 服务器主循环、命令执行入口、持久化触发逻辑。
- `config.c`: 配置文件解析和持久化相关配置项的处理。
- `bio.c`: 后台 IO 线程，用于执行 `fsync` 等耗时操作。

---

## 6. 总结

Redis 通过 RDB 和 AOF 提供了灵活且可靠的数据持久化方案。RDB 适合做冷备份和快速恢复大数据集，但可能丢失较多数据。AOF 数据安全性更高，但文件更大且恢复较慢。混合持久化则试图结合两者的优点。理解它们的实现原理、触发机制、文件格式以及重写过程，有助于我们更好地配置和使用 Redis，确保数据安全和系统性能。
